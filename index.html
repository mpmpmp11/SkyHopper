<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Sky Hoppers</title>
<meta name="viewport" content="width=288, initial-scale=1, maximum-scale=1, user-scalable=no" />
<style>
  html, body {
    margin: 0;
    background: #000;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    -webkit-tap-highlight-color: transparent;
  }
  canvas {
    width: 288px;   /* mobile portrait â€“ no CSS scaling beyond 1:1 */
    height: 512px;
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    touch-action: manipulation;
  }
  @font-face {
    font-family: "Flappy";
    src: url("flappy.ttf");
    font-display: swap;
  }
</style>
</head>
<body>
<canvas id="game" width="288" height="512"></canvas>

<script>
(() => {
  // -------------------------------------------------
  // Canvas / Context
  // -------------------------------------------------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  ctx.imageSmoothingEnabled = false;
  const W = canvas.width, H = canvas.height;
  const i = n => n|0; // fast int floor for pixel-perfect draws

  // -------------------------------------------------
  // Assets (EXACT NAMES)
  // -------------------------------------------------
  const IMG = {};
  const ASSETS = {
    bg: "backround.png",        // yes, spelled like that per your files
    ground: "ground.png",
    bird: "bird.png",
    logo: "logo.png",
    start: "start.png",
    skins: "skins.png",
    leader: "leaderboards.png",
    settings: "settings.png",
    back: "back.png",
    pause: "pause.png",
    gameover: "gameover.png",
    playagain: "playagain.png",
    exit: "exit.png",
    pipe_head: "pipe_head.png", // 52x26
    pipe_body: "pipe_body.png"  // 52x16 (tileable)
  };
  function loadImage(src){
    return new Promise((resolve, reject)=>{
      const im = new Image();
      im.onload = ()=>resolve(im);
      im.onerror = ()=>reject(new Error("Missing image: "+src));
      im.src = src;
    });
  }

  // -------------------------------------------------
  // Audio
  // -------------------------------------------------
  const SFX = {
    swoosh: new Audio("swoosh.waw"),
    music:  new Audio("8-bit.waw"),
  };
  SFX.music.loop = true;
  SFX.swoosh.volume = 0.7;
  SFX.music.volume = 0.3;

  let muteSFX = false;
  let muteMusic = false;
  function playFlap(){
    if (muteSFX) return;
    try { SFX.swoosh.currentTime = 0; SFX.swoosh.play(); } catch (e) {}
  }
  function ensureMusic(){
    if (muteMusic) { SFX.music.pause(); return; }
    try { if (SFX.music.paused) SFX.music.play(); } catch (e) {}
  }

  // -------------------------------------------------
  // Game Constants
  // -------------------------------------------------
  const STATE = {
    MENU:0, PLAY:1, PAUSED:2, GAMEOVER:3,
    POPUP_SKINS:4, POPUP_LEADER:5, POPUP_SETTINGS:6
  };
  let state = STATE.MENU;
  let prevStateForPopup = STATE.MENU;

  // Pixel-perfect Flappy feel
  const SPEED = 3;                // world scroll speed (px/frame)
  const GRAVITY = 0.25;           // bird accel (px/frame^2)
  const JUMP = -4.6;              // bird instant vel on flap
  const PIPE_W = 52;              // drawn pipe width
  const GAP_MIN = 95, GAP_MAX = 135;
  const SPAWN_FRAMES = 90;

  // UI Rects (square buttons theme)
  const UI = {
    logo:       { w:200, h:80,  x:(W-200)/2, y:40 },
    start:      { w:80,  h:80,  x:(W-80)/2,  y:150 },
    skins:      { w:80,  h:80,  x:(W-80)/2,  y:240 },
    leader:     { w:80,  h:80,  x:(W-80)/2,  y:330 },
    settings:   { w:80,  h:80,  x:(W-80)/2,  y:420 },
    pause:      { w:50,  h:50,  x:8,         y:8  },
    back:       { w:50,  h:50,  x:W-58,      y:8  },
    gameover:   { w:200, h:60,  x:(W-200)/2, y:130 },
    playAgain:  { w:80,  h:80,  x:(W-80)/2,  y:300 },
    exit:       { w:80,  h:80,  x:(W-80)/2,  y:390 }
  };

  // -------------------------------------------------
  // World / Ground
  // -------------------------------------------------
  const groundY = () => H - IMG.ground.height; // ground strip height defines floor
  let groundX = 0;
  function drawBG(){ ctx.drawImage(IMG.bg, 0, 0, W, H); }
  function drawGround(move=true){
    if (move) groundX = (groundX - SPEED) % IMG.ground.width;
    let start = groundX;
    while (start > 0) start -= IMG.ground.width;
    for (let x = start; x < W; x += IMG.ground.width){
      ctx.drawImage(IMG.ground, i(x), groundY());
    }
  }

  // -------------------------------------------------
  // Bird
  // -------------------------------------------------
  const bird = {
    x: 52, y: 230, w: 34, h: 24,
    vy: 0,
    flap(){
      this.vy = JUMP;
      playFlap();
      spawnFlapBurst(this.x + this.w*0.4, this.y + this.h*0.9);
    },
    step(){
      this.vy += GRAVITY;
      this.y += this.vy;
      // top/bottom death check
      if (this.y <= 0) return true;
      const gY = groundY();
      if (this.y + this.h >= gY){
        this.y = gY - this.h;
        return true;
      }
      return false;
    },
    draw(){
      ctx.drawImage(IMG.bird, i(this.x), i(this.y), this.w, this.h);
    }
  };

  // -------------------------------------------------
  // Pipes (using head+body for crisp, non-squished look)
  // -------------------------------------------------
  let pipes = [];
  let spawnTimer = 0;

  function rInt(a,b){ return (Math.random()*(b-a+1)|0)+a; }

  function spawnPipe(){
    const gap = rInt(GAP_MIN, GAP_MAX);
    const topLimit = 30 + (gap>>1);
    const bottomLimit = (groundY() - 30) - (gap>>1);
    const center = rInt(topLimit, bottomLimit);
    const topH = Math.max(10, center - (gap>>1));
    const bottomY = center + (gap>>1);

    pipes.push({
      x: W + 2,
      w: PIPE_W,
      topH: topH,
      bottomY: bottomY,
      passed: false
    });
  }

  function stepPipes(){
    for (const p of pipes) p.x -= SPEED;
    while (pipes.length && pipes[0].x + pipes[0].w < 0) pipes.shift();
  }

  function drawOnePipe(x, fromY, toY, flip=false){
    const head = IMG.pipe_head, body = IMG.pipe_body;
    const w = PIPE_W;
    const headH = head.height; // expect 26
    const bodyH = body.height; // expect 16
    if (!head || !body) return;

    if (!flip){
      // bottom pipe grows up (from fromY to toY)
      const bodyTop = fromY + headH;
      // body tiles
      for (let y = bodyTop; y < toY; y += bodyH){
        const segH = Math.min(bodyH, toY - y);
        ctx.drawImage(body, 0, 0, body.width, segH, i(x), i(y), w, segH);
      }
      // cap head
      ctx.drawImage(head, i(x), i(fromY), w, headH);
    } else {
      // top pipe flips vertically to grow downwards (0..toY)
      const headY = toY - headH;
      ctx.save();
      ctx.translate(i(x), i(headY + headH));
      ctx.scale(1, -1);
      // draw head
      ctx.drawImage(head, 0, 0, w, headH, 0, 0, w, headH);
      // body tiles upward in flipped space
      let y = headH;
      while (y < toY){
        const segH = Math.min(bodyH, toY - y);
        ctx.drawImage(body, 0, 0, w, segH, 0, y, w, segH);
        y += segH;
      }
      ctx.restore();
    }
  }

  function drawPipes(){
    const gY = groundY();
    for (const p of pipes){
      // top pipe: [0..topH]
      drawOnePipe(p.x, 0, p.topH, /*flip=*/true);
      // bottom pipe: [bottomY..groundY]
      drawOnePipe(p.x, p.bottomY, gY, /*flip=*/false);
    }
  }

  function collides(){
    // fair hitbox
    const bx = bird.x + 2, by = bird.y + 2, bw = bird.w - 4, bh = bird.h - 4;
    for (const p of pipes){
      const overlapX = (bx < p.x + p.w) && (bx + bw > p.x);
      if (!overlapX) continue;
      if (by < p.topH || (by + bh) > p.bottomY) return true;
    }
    return false;
  }

  // -------------------------------------------------
  // Score
  // -------------------------------------------------
  let score = 0;
  let best = Number(localStorage.getItem("bestScore") || 0);
  function advanceScore(){
    for (const p of pipes){
      if (!p.passed && p.x + p.w < bird.x){
        p.passed = true;
        score++;
        spawnScoreBurst(bird.x + bird.w/2, 60); // little sparkles near score
      }
    }
  }

  // -------------------------------------------------
  // Particles (flap burst + death poof + score sparkles)
  // -------------------------------------------------
  const particles = [];
  function spawnFlapBurst(x,y){
    for (let k=0;k<8;k++){
      particles.push({
        x, y,
        vx: (Math.random()*2-1)*1.5,
        vy: (Math.random()*-1.2-0.2),
        life: 20 + ((Math.random()*6)|0),
        type: 'dust'
      });
    }
  }
  function spawnDeathPoof(x,y){
    for (let k=0;k<18;k++){
      const ang = Math.random()*Math.PI*2;
      const spd = 1 + Math.random()*2.5;
      particles.push({
        x, y,
        vx: Math.cos(ang)*spd,
        vy: Math.sin(ang)*spd,
        life: 28 + ((Math.random()*10)|0),
        type: 'poof'
      });
    }
  }
  function spawnScoreBurst(x,y){
    for (let k=0;k<6;k++){
      particles.push({
        x: x + (Math.random()*16-8),
        y: y + (Math.random()*8-4),
        vx: (Math.random()*2-1)*0.5,
        vy: - (0.4 + Math.random()*0.6),
        life: 18 + ((Math.random()*6)|0),
        type: 'spark'
      });
    }
  }
  function stepParticles(){
    for (const p of particles){
      p.x += p.vx;
      p.y += p.vy;
      if (p.type === 'dust') p.vy += 0.05;
      else if (p.type === 'poof') p.vy += 0.03;
      p.life--;
    }
    while (particles.length && particles[0].life <= 0) particles.shift();
  }
  function drawParticles(){
    for (const p of particles){
      const a = Math.max(0, Math.min(1, p.life/28));
      if (p.type === 'dust'){
        ctx.fillStyle = `rgba(255,255,255,${0.25*a})`;
        ctx.fillRect(i(p.x), i(p.y), 2, 2);
      } else if (p.type === 'poof'){
        ctx.fillStyle = `rgba(255,255,255,${0.35*a})`;
        ctx.fillRect(i(p.x), i(p.y), 2, 2);
      } else { // spark
        ctx.fillStyle = `rgba(255,255,255,${0.6*a})`;
        ctx.fillRect(i(p.x), i(p.y), 1, 3);
      }
    }
  }

  // -------------------------------------------------
  // Text helpers
  // -------------------------------------------------
  function drawTextCentered(txt, x, y, size){
    ctx.font = `${size}px Flappy, Arial, sans-serif`;
    ctx.textAlign = "center";
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#000";
    ctx.fillStyle = "#fff";
    ctx.strokeText(txt, i(x), i(y));
    ctx.fillText(txt, i(x), i(y));
    ctx.textAlign = "left";
  }
  function drawSmallLeft(txt, x, y, size){
    ctx.font = `${size}px Flappy, Arial, sans-serif`;
    ctx.textAlign = "left";
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#000";
    ctx.fillStyle = "#fff";
    ctx.strokeText(txt, i(x), i(y));
    ctx.fillText(txt, i(x), i(y));
  }

  // -------------------------------------------------
  // UI drawing + subtle menu animation
  // -------------------------------------------------
  let menuPulse = 0;
  function drawMenu(){
    drawBG();
    drawGround(true);

    // Subtle floating logo
    menuPulse += 0.05;
    const bob = Math.sin(menuPulse)*2; // 2px bob
    ctx.drawImage(IMG.logo, i(UI.logo.x), i(UI.logo.y + bob), UI.logo.w, UI.logo.h);

    // Glow under Start (tiny pulse)
    const pulse = 0.5 + 0.5*Math.sin(menuPulse*2);
    ctx.globalAlpha = 0.15*pulse;
    ctx.fillStyle = "#fff";
    ctx.fillRect(i(UI.start.x-4), i(UI.start.y-4), UI.start.w+8, UI.start.h+8);
    ctx.globalAlpha = 1;

    // Buttons
    ctx.drawImage(IMG.start,     i(UI.start.x),    i(UI.start.y),    UI.start.w,    UI.start.h);
    ctx.drawImage(IMG.skins,     i(UI.skins.x),    i(UI.skins.y),    UI.skins.w,    UI.skins.h);
    ctx.drawImage(IMG.leader, i(UI.leader.x), i(UI.leader.y), UI.leader.w, UI.leader.h);
    ctx.drawImage(IMG.settings,  i(UI.settings.x), i(UI.settings.y), UI.settings.w, UI.settings.h);
  }

  function drawGame(){
    drawBG();
    drawPipes();
    drawGround(true);
    bird.draw();
    drawParticles();

    // Pause button
    ctx.drawImage(IMG.pause, i(UI.pause.x), i(UI.pause.y), UI.pause.w, UI.pause.h);

    // Score
    drawTextCentered(String(score), W/2, 48, 28);
  }

  function drawPausedOverlay(countdown){
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0,0,W,H);
    drawTextCentered("GAME PAUSED", W/2, 200, 24);
    if (countdown > 0){
      drawTextCentered(String(countdown), W/2, 250, 48);
    } else {
      drawTextCentered("TAP ANYWHERE TO PLAY", W/2, 250, 16);
    }
  }

  function drawPopup(title, subtitle){
    drawBG();
    drawGround(false);
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(0,0,W,H);
    drawTextCentered(title, W/2, 160, 22);
    if (subtitle) drawTextCentered(subtitle, W/2, 200, 18);
    ctx.drawImage(IMG.back, i(UI.back.x), i(UI.back.y), UI.back.w, UI.back.h);
  }

  function drawSettings(){
    drawBG();
    drawGround(false);
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(0,0,W,H);
    drawTextCentered("SETTINGS", W/2, 130, 24);

    const leftX = 36, valX = W - 36;
    drawSmallLeft("SFX", leftX, 190, 20);
    drawSmallLeft(muteSFX ? "OFF" : "ON", valX-40, 190, 20);
    drawSmallLeft("MUSIC", leftX, 230, 20);
    drawSmallLeft(muteMusic ? "OFF" : "ON", valX-40, 230, 20);
    drawTextCentered("Tap to toggle", W/2, 270, 14);

    ctx.drawImage(IMG.back, i(UI.back.x), i(UI.back.y), UI.back.w, UI.back.h);
  }

  function drawGameOver(){
    drawBG();
    drawPipes();
    drawGround(false);
    bird.draw();
    drawParticles();

    ctx.drawImage(IMG.gameover, i(UI.gameover.x), i(UI.gameover.y), UI.gameover.w, UI.gameover.h);
    drawTextCentered(`Score: ${score}`, W/2, 210, 18);
    drawTextCentered(`High Score: ${best}`, W/2, 240, 18);
    ctx.drawImage(IMG.playagain, i(UI.playAgain.x), i(UI.playAgain.y), UI.playAgain.w, UI.playAgain.h);
    ctx.drawImage(IMG.exit, i(UI.exit.x), i(UI.exit.y), UI.exit.w, UI.exit.h);
  }

  // -------------------------------------------------
  // Game Flow
  // -------------------------------------------------
  let frames = 0;
  let pauseCountdown = 0;
  let keyHeld = false;

  function resetRun(){
    pipes = [];
    particles.length = 0;
    bird.y = 230;
    bird.vy = 0;
    score = 0;
    spawnTimer = 0;
  }

  function update(){
    if (state === STATE.PLAY){
      spawnTimer++;
      if (spawnTimer >= SPAWN_FRAMES){ spawnTimer = 0; spawnPipe(); }
      stepPipes();
      if (bird.step() || collides()){
        // death
        spawnDeathPoof(bird.x + bird.w/2, bird.y + bird.h/2);
        state = STATE.GAMEOVER;
        best = Math.max(best, score);
        localStorage.setItem("bestScore", String(best));
        return;
      }
      advanceScore();
      stepParticles();
    } else if (state === STATE.MENU){
      // allow idle particles to fade
      stepParticles();
    } else if (state === STATE.GAMEOVER){
      // tiny particle drift
      stepParticles();
    }
  }

  function render(){
    if (state === STATE.MENU) {
      drawMenu();
    } else if (state === STATE.PLAY) {
      drawGame();
    } else if (state === STATE.PAUSED) {
      drawBG();
      drawPipes();
      drawGround(false);
      bird.draw();
      drawParticles();
      ctx.drawImage(IMG.pause, i(UI.pause.x), i(UI.pause.y), UI.pause.w, UI.pause.h);
      drawTextCentered(String(score), W/2, 48, 28);
      drawPausedOverlay(pauseCountdown);
    } else if (state === STATE.POPUP_SKINS) {
      drawPopup("SKINS - COMING SOON!");
    } else if (state === STATE.POPUP_LEADER) {
      drawPopup("LEADERBOARDS - COMING SOON!");
    } else if (state === STATE.POPUP_SETTINGS) {
      drawSettings();
    } else if (state === STATE.GAMEOVER) {
      drawGameOver();
    }
  }

  function loop(){
    update();
    render();
    frames++;
    requestAnimationFrame(loop);
  }

  // -------------------------------------------------
  // Input
  // -------------------------------------------------
  function canvasPos(e){
    const r = canvas.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - r.left;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - r.top;
    return {x,y};
  }
  function inRect(x,y,r){ return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }

  function handleTap(x,y){
    if (state === STATE.MENU){
      ensureMusic();
      if (inRect(x,y,UI.start)){ state = STATE.PLAY; resetRun(); bird.flap(); return; }
      if (inRect(x,y,UI.skins)){ prevStateForPopup = STATE.MENU; state = STATE.POPUP_SKINS; return; }
      if (inRect(x,y,UI.leader)){ prevStateForPopup = STATE.MENU; state = STATE.POPUP_LEADER; return; }
      if (inRect(x,y,UI.settings)){ prevStateForPopup = STATE.MENU; state = STATE.POPUP_SETTINGS; return; }
      return;
    }
    if (state === STATE.PLAY){
      if (inRect(x,y,UI.pause)){ state = STATE.PAUSED; pauseCountdown = 0; return; }
      bird.flap();
      return;
    }
    if (state === STATE.PAUSED){
      if (inRect(x,y,UI.back)){ state = STATE.MENU; return; }
      if (pauseCountdown === 0) pauseCountdown = 3; // start countdown
      return;
    }
    if (state === STATE.POPUP_SETTINGS){
      // Toggle zones
      if (y >= 175 && y <= 200){ muteSFX = !muteSFX; return; }
      if (y >= 215 && y <= 240){ muteMusic = !muteMusic; ensureMusic(); return; }
      if (inRect(x,y,UI.back)){ state = prevStateForPopup; return; }
      return;
    }
    if (state === STATE.POPUP_SKINS || state === STATE.POPUP_LEADER){
      if (inRect(x,y,UI.back)){ state = prevStateForPopup; return; }
      return;
    }
    if (state === STATE.GAMEOVER){
      if (inRect(x,y,UI.playAgain)){ state = STATE.PLAY; resetRun(); bird.flap(); ensureMusic(); return; }
      if (inRect(x,y,UI.exit)){ state = STATE.MENU; return; }
      return;
    }
  }

  canvas.addEventListener('mousedown', e=>{ const p = canvasPos(e); handleTap(p.x,p.y); });
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); const p = canvasPos(e); handleTap(p.x,p.y); }, {passive:false});

  document.addEventListener('keydown', e=>{
    if (e.code === 'Space' && !keyHeld){
      keyHeld = true;
      if (state === STATE.MENU){ state = STATE.PLAY; resetRun(); bird.flap(); ensureMusic(); return; }
      if (state === STATE.PLAY){ bird.flap(); return; }
      if (state === STATE.PAUSED){ if (pauseCountdown === 0) pauseCountdown = 3; return; }
      if (state === STATE.GAMEOVER){ state = STATE.PLAY; resetRun(); bird.flap(); ensureMusic(); return; }
    }
    if (e.code === 'KeyP' && state === STATE.PLAY){ state = STATE.PAUSED; pauseCountdown = 0; }
  });
  document.addEventListener('keyup', e=>{ if (e.code === 'Space') keyHeld = false; });

  // Countdown tick (resume after pause)
  setInterval(()=>{
    if (state === STATE.PAUSED && pauseCountdown > 0){
      pauseCountdown--;
      if (pauseCountdown === 0){ state = STATE.PLAY; }
    }
  }, 1000);

  // -------------------------------------------------
  // Boot
  // -------------------------------------------------
  (async function boot(){
    try{
      const keys = Object.keys(ASSETS);
      const imgs = await Promise.all(keys.map(k => loadImage(ASSETS[k])));
      keys.forEach((k,i)=> IMG[k] = imgs[i]);

      // Sanity checks for pipe assets
      if (IMG.pipe_head.width !== 52) console.warn("pipe_head.png should be 52px wide");
      if (IMG.pipe_body.width !== 52) console.warn("pipe_body.png should be 52px wide");

      ensureMusic();
      loop();
    }catch(err){
      console.error(err);
      alert(err.message + "\nMake sure all files are next to index.html with EXACT names.");
    }
  })();

})();
</script>
</body>
</html>
